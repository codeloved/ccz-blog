import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as b,e as n,b as e,a as l,d as t,w as a,r,o as p}from"./app-DVVG4u63.js";const h={};function g(u,i){const s=r("Mermaid"),o=r("font");return p(),b("div",null,[i[12]||(i[12]=n('<h2 id="git存储方式" tabindex="-1"><a class="header-anchor" href="#git存储方式"><span>git存储方式</span></a></h2><ul><li>特点 <br> git保存的不是文件的变化或者差异, 而是一系列不同时刻的快照</li><li>blob对象 <br> 保存着文件的快照, 使用blob格式保存<strong>文件的内容</strong></li><li>树对象 <br> 保存着文件名和对应的blob对象引用地址, 使用<strong>树格式保存文件目录结构</strong></li><li>提交对象 <br> 保存着树对象引用地址和作者、提交信息等信息, 使用提交格式保存提交记录</li></ul>',2)),e(s,{id:"mermaid-25",code:"eJyNj7EKAjEMhvc+RXa54a67g7oITuouvVpq4JpCGxfFd7et9aAHghkCX/LnT6InFeMOlQ3KiSsGoxk9weEoSge23jlkeApIsToHY4BT+uCJA5IFdeebD01J5zHii4tWvKpVGa5Ge2KI+Kg+m8mPMKbUL3hYsJzNcqn/us1LiQ1xoxn+0Mifmvp9163L9aK8kKmsb3FoUYo3QFdpdQ=="}),l("ul",null,[l("li",null,[e(o,{color:"red"},{default:a(()=>i[0]||(i[0]=[t("总结")])),_:1}),i[1]||(i[1]=t()),i[2]||(i[2]=l("ol",null,[l("li",null,"git每次提交时, 会产生一个提交对象, 这个对象保存了提交的作者的姓名, 邮箱, 提交时输入的信息")],-1)),i[3]||(i[3]=l("ul",null,[l("li",null,"还保存了一个指向暂存对象(树对象)的指针, 这个树对象保存了所有文件的快照的引用和目录结构, 可以快速还原整个工作区"),l("li",null,"第一个提交对象没有指向父提交对象, 合并的提交对象指向2个父提交对象, 普通的提交有一个父提交对象"),l("li",null,"初始化数据库, 会有一个分支指针, master指向最后一个提交对象"),l("li",null,[t("存储结构总结为 提交对象 --> 树对象 --> 文件快照(Blob), 后面的讲解都是到提交对象, 不再涉及提交对象下级的对象 "),l("br"),t(" 只有提交对象和别的提交对象有关系, 树对象和Blob对象, 只和当前的提交对象有关系")])],-1)),i[4]||(i[4]=l("ol",{start:"2"},[l("li",null,"为了节省空间, 如果文件没有改变, 则文件不会产生新的Blob对象, 树对象的指向会复用原先的Blob对象")],-1))])]),i[13]||(i[13]=l("h2",{id:"分支的操作",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#分支的操作"},[l("span",null,"分支的操作")])],-1)),i[14]||(i[14]=l("ul",null,[l("li",null,[t("分支的本质 "),l("br"),t(" 分支的本质, 仅仅是指向提交对象的可变指针, 不保存任何分支相关的内容")])],-1)),e(s,{id:"mermaid-78",code:"eJxLy8kvT85ILCpRCPLhykwxjjYxTTMxiFXQ1bVTyEwxijZKMzFNhHENoy0SzUxTYrlyE4tLUougosZcZYZ6BnCOh6ujC5gDUcQFAH5tG0Q="}),l("ul",null,[l("li",null,[i[5]||(i[5]=n(`<p>分支创建 <br> 本质就是创建一个指针, 指向某个提交对象</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 创建一个指向当前提交对象的指针feat</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> branch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> feat</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),e(s,{id:"mermaid-85",code:"eJxLy8kvT85ILCpRCPLhykwxjjYxTTMxiFXQ1bVTyEwxijZKMzFNhHENoy0SzUxTYrlyE4tLUougosZcZYZ6BnCOh6ujC5gDUcSVlppYAuRDZQEbTB7z"}),i[6]||(i[6]=l("p",null,"此时, v1.0, feat, master均指向最后一个提交, 那么如何区分当前在哪个分支上? HEAD指针指向的就是当前的分支",-1)),i[7]||(i[7]=l("ul",null,[l("li",null,[t("分支的本质, 查看.git/refs目录下可以得知, 分支名即为文件名, 分支指向的commit对象的hash值, 就是文件的内容 "),l("br"),t(" 所以新建一个分支, 就是在.git/refs目录下新建一个分支名的文件, 内部保存了commit对象的hash值")])],-1))]),i[8]||(i[8]=l("li",null,[l("p",null,[t("HEAD指针 "),l("br"),t(" 指向当前所在分支")])],-1))]),i[15]||(i[15]=n(`<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 此命令可以展示e380ee3 (HEAD -&gt; master, feat, v1.0), 可以知道此时分支是master, 也会列出指向该提交的其他分支指针</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> log</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --oneline</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l("ul",null,[l("li",null,[i[9]||(i[9]=n('<p>分支切换 本质就是切换HEAD指针指向</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> checkout</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> feat</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',2)),e(s,{id:"mermaid-110",code:"eJxLy8kvT85ILCpRCPLhykwxjjYxTTMxiFXQ1bVTyEwxijZKMzFNhHENoy0SzUxTYrlyE4tLUougosZcZYZ6BnBOWmpiCZAD5Xm4OrqApUDCXADYrR4H"}),i[10]||(i[10]=l("ul",null,[l("li",null,"分支切换会重建工作目录, 如果工作区有未提交内容且和切换分支有冲突, 切换分支会失败, 所以切换分支前, 最好先提交或者暂存当前工作目录")],-1))]),l("li",null,[e(o,{color:"red"},{default:a(()=>i[11]||(i[11]=[t("HEAD会随分支指针一起移动")])),_:1})])]),i[16]||(i[16]=l("p",null,"假设, 此时feat分支新增一个提交id4(3a4c5)",-1)),e(s,{id:"mermaid-127",code:"eJxLy8kvT85ILCpRCPLhykwxiTZONEk2jVXQ1bVTyEwxjjYxTTMxgHGNoo3STEwTYVzDaItEM9OUWK601MQSoBhY0ITLw9XRBawCJMyVm1hckloEM4+rzFDPAM4BAL1zIfk="})])}const c=d(h,[["render",g]]),y=JSON.parse('{"path":"/blog/tools/git/branch.html","title":"分支简介","lang":"zh-CN","frontmatter":{"title":"分支简介","article":false,"index":true,"order":3,"description":"git存储方式 特点 git保存的不是文件的变化或者差异, 而是一系列不同时刻的快照 blob对象 保存着文件的快照, 使用blob格式保存文件的内容 树对象 保存着文件名和对应的blob对象引用地址, 使用树格式保存文件目录结构 提交对象 保存着树对象引用地址和作者、提交信息等信息, 使用提交格式保存提交记录 git每次提交时, 会产生一个提交对象,...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"分支简介\\",\\"description\\":\\"git存储方式 特点 git保存的不是文件的变化或者差异, 而是一系列不同时刻的快照 blob对象 保存着文件的快照, 使用blob格式保存文件的内容 树对象 保存着文件名和对应的blob对象引用地址, 使用树格式保存文件目录结构 提交对象 保存着树对象引用地址和作者、提交信息等信息, 使用提交格式保存提交记录 git每次提交时, 会产生一个提交对象,...\\"}"],["meta",{"property":"og:url","content":"https://codeloved.github.io/ccz-blog/ccz-blog/blog/tools/git/branch.html"}],["meta",{"property":"og:site_name","content":"首页"}],["meta",{"property":"og:title","content":"分支简介"}],["meta",{"property":"og:description","content":"git存储方式 特点 git保存的不是文件的变化或者差异, 而是一系列不同时刻的快照 blob对象 保存着文件的快照, 使用blob格式保存文件的内容 树对象 保存着文件名和对应的blob对象引用地址, 使用树格式保存文件目录结构 提交对象 保存着树对象引用地址和作者、提交信息等信息, 使用提交格式保存提交记录 git每次提交时, 会产生一个提交对象,..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-24T14:31:12.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-24T14:31:12.000Z"}]]},"git":{"createdTime":1745505072000,"updatedTime":1745505072000,"contributors":[{"name":"ccz","username":"ccz","email":"ccz@email","commits":1,"url":"https://github.com/ccz"}]},"readingTime":{"minutes":3.14,"words":942},"filePathRelative":"blog/tools/git/branch.md","excerpt":"<h2>git存储方式</h2>\\n<ul>\\n<li>特点 <br>\\ngit保存的不是文件的变化或者差异, 而是一系列不同时刻的快照</li>\\n<li>blob对象 <br>\\n保存着文件的快照, 使用blob格式保存<strong>文件的内容</strong></li>\\n<li>树对象 <br>\\n保存着文件名和对应的blob对象引用地址, 使用<strong>树格式保存文件目录结构</strong></li>\\n<li>提交对象 <br>\\n保存着树对象引用地址和作者、提交信息等信息, 使用提交格式保存提交记录</li>\\n</ul>\\n<ul>\\n<li>\\n <ol>\\n<li>git每次提交时, 会产生一个提交对象, 这个对象保存了提交的作者的姓名, 邮箱, 提交时输入的信息</li>\\n</ol>\\n<ul>\\n<li>还保存了一个指向暂存对象(树对象)的指针, 这个树对象保存了所有文件的快照的引用和目录结构, 可以快速还原整个工作区</li>\\n<li>第一个提交对象没有指向父提交对象, 合并的提交对象指向2个父提交对象, 普通的提交有一个父提交对象</li>\\n<li>初始化数据库, 会有一个分支指针, master指向最后一个提交对象</li>\\n<li>存储结构总结为 提交对象 --&gt; 树对象 --&gt; 文件快照(Blob), 后面的讲解都是到提交对象, 不再涉及提交对象下级的对象 <br>\\n只有提交对象和别的提交对象有关系, 树对象和Blob对象, 只和当前的提交对象有关系</li>\\n</ul>\\n<ol start=\\"2\\">\\n<li>为了节省空间, 如果文件没有改变, 则文件不会产生新的Blob对象, 树对象的指向会复用原先的Blob对象</li>\\n</ol>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,y as data};
