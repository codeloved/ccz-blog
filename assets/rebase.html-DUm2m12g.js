import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,a as s,d as l,b as a,w as t,e as r,r as h,o as p}from"./app-ta2cu9-p.js";const g={};function o(b,i){const e=h("font"),n=h("Mermaid");return p(),k("div",null,[i[33]||(i[33]=s("h2",{id:"git变基",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#git变基"},[s("span",null,"git变基 \\")])],-1)),s("p",null,[i[3]||(i[3]=l("git 合并其他分支的修改3种方式")),a(e,{color:"red"},{default:t(()=>i[0]||(i[0]=[l("merge")])),_:1}),i[4]||(i[4]=l(" 、")),a(e,{color:"red"},{default:t(()=>i[1]||(i[1]=[l("rebase")])),_:1}),i[5]||(i[5]=l("、")),a(e,{color:"red"},{default:t(()=>i[2]||(i[2]=[l("cherry-pick")])),_:1})]),s("ul",null,[s("li",null,[i[19]||(i[19]=s("p",null,[l("使用merge合并2个分支 "),s("br"),l(" 假设开发分支feat和master, 在b2时分别有开发变更, 现在要将feat合并到master")],-1)),i[20]||(i[20]=s("ol",null,[s("li",null,"合并前(在master分支)")],-1)),a(n,{id:"mermaid-18",code:"eJxLy8kvT85ILCpRCPLhSjJS0NW1U0gyhFAGXEnGEJYRV25icUlqEYRnzJVkAhNPS00sgbBNuAAR9BM4"}),i[21]||(i[21]=s("ol",{start:"2"},[s("li",null,"合并后(git merge feat)")],-1)),a(n,{id:"mermaid-26",code:"eJxLy8kvT85ILCpRCPLhSjJS0NW1U0gyhFAGXEnGEJYRV5IphGUMZ5lwJZnAZNNSE0tgormJxSWpRRCeKRcAjD8XVw=="}),a(e,{color:"red"},{default:t(()=>i[6]||(i[6]=[l("注意:")])),_:1}),i[22]||(i[22]=l("此时不满足快速合并, 会生成一个新的合并记录b5, 有2个父提交, master分支指向新的b5提交")),s("ul",null,[s("li",null,[i[14]||(i[14]=l("使用rebase合并2个分支 ")),i[15]||(i[15]=s("ol",null,[s("li",null,"合并前(在feat分支)")],-1)),a(n,{id:"mermaid-41",code:"eJxTUEjLyS9PzkgsKlEI8uFSUEgyUtDVtVNIMoRQBiAhYwjbCMjOTSwuSS2C8I1BciYIubTUxBIIz4QLAMUyFLg="}),i[16]||(i[16]=r(`<ol start="2"><li>rebase后(git rebase master)</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> checkout</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> feat</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rebase</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> master</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),a(n,{id:"mermaid-50",code:"eJxTAIK0nPzy5IzEohKFIB8ukECSkYKurp1CkiGEMoAIGkN4RmBebmJxSWoRRMQYIm8C5FXA5JNM1JEl01ITSyB8E3UuAAPBGU0="}),a(e,{color:"red"},{default:t(()=>i[7]||(i[7]=[l("原理:")])),_:1}),i[17]||(i[17]=r(` 先找到feat和master的共同祖先b2, 然后将当前分支(feat)基于共同祖先b2的历次提交暂存起来然后将当前分支feat指向目标分支master的最新提交b3, 再将暂存的提交以b3为基底重新提交一遍 <br> 总结就是, 相当于feat从基于共同最近祖先的提交(新增的提交)断开, 以master的最新提交为基底, 重演一遍断开的提交, 提交的id会改变, 也可能会存在冲突,需要解决冲突后继续提交,看起来好像是从master的b3处开始开发的, 然后再使用快速合并<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> checkout</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> master</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> merge</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> feat</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,4)),a(n,{id:"mermaid-57",code:"eJxTAIK0nPzy5IzEohKFIB8ukECSkYKurp1CkiGEMoAIGkN4RhCeiTqEawzmpqUmlkD4JupggdzE4pLUIrgQALCyFq8="}),a(e,{color:"red"},{default:t(()=>i[8]||(i[8]=[l("总结:")])),_:1}),i[18]||(i[18]=l()),s("ol",null,[i[11]||(i[11]=s("li",null,[l("无论是直接合并的得到的b5, 还是先rebase再merge得到的b4', 指向的最终快照结果是完全一样的, 唯一的区别是提交的历史记录 "),s("br"),l(" 如果先rebase再merge, 得到的提交历史是一条没有分叉的直线, 而不是直接合并会有一个合并节点, 使得并行工作的任务的提交记录,看起来和串行工作的提交记录一样的")],-1)),i[12]||(i[12]=s("li",null,"一般使用情况, 先使用git fetch抓取最新的远程分支, 再使用git rebase origin/master变基, 然后推送到远端, 这样别人合并代码到主分支时, 不需要处理整合操作, 只需要快速合并即可",-1)),i[13]||(i[13]=s("li",null,"不论是rebase还是直接merge, 最终得到的快照结果, 一定是一样的, 唯一有区别的是提交历史",-1)),s("li",null,[a(e,{color:"red"},{default:t(()=>i[9]||(i[9]=[l("千万千万注意:")])),_:1}),i[10]||(i[10]=l(" 如果别人也基于相同远端分支开发, 并且已经检出了, 千万不要rebase, 会导致其他人的工作内容丢失和处理烦恼"))])])])])])]),i[34]||(i[34]=s("h2",{id:"重写提交历史",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#重写提交历史"},[s("span",null,"重写提交历史")])],-1)),s("ul",null,[i[32]||(i[32]=s("li",null,[s("p",null,"原因"),s("ol",null,[s("li",null,"可能对提交的commit信息不满意, 需要重写commit信息"),s("li",null,"可能对提交的历史记录不满意, 需要合并提交或者删除提交等"),s("li",null,"修改历史的原则, 是在本地未提交远端的历史, 或者已经提交, 但是未共享给他人的历史, 切记不能重写影响他人的历史")])],-1)),s("li",null,[i[30]||(i[30]=r(`<p>修改最后的一次提交</p><ol><li>修改最后一次提交的提交信息</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> commit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --amend</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>修改最后一次的提交信息或者提交内容</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 先将内容暂存</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> add</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> .</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 提交此次暂存内容的同时, 修改最近的一次条信息, 相当于将本次的修改, 合并到最近的一次提交中</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> commit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --amend</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>修改多个提交信息(git rebase -i)</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 修改最近的三次提交信息</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rebase</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> HEAD~3</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 得到内容, 注意提交信息的排序是由远到近, 最后一个提交记录f40f0df是最近的提交</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pick</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> e2e3790</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> add</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pick</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 90de6eb</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> test</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pick</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> f40f0df</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rebase</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 变基 776327d..f40f0df 到 776327d（3 个提交）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 命令:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># p, pick &lt;提交&gt; = 使用提交</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># r, reword &lt;提交&gt; = 使用提交，但编辑提交说明</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># e, edit &lt;提交&gt; = 使用提交，但停止以便修补提交</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># s, squash &lt;提交&gt; = 使用提交，但挤压到前一个提交</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># f, fixup [-C | -c] &lt;提交&gt; = 类似于 &quot;squash&quot;，但只保留前一个提交</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#                    的提交说明，除非使用了 -C 参数，此情况下则只</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#                    保留本提交说明。使用 -c 和 -C 类似，但会打开</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#                    编辑器修改提交说明</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># x, exec &lt;命令&gt; = 使用 shell 运行命令（此行剩余部分）</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 修改以上内容, 常用命名s, r, p, d, e</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7)),s("ul",null,[s("li",null,[a(e,{color:"red"},{default:t(()=>i[23]||(i[23]=[l("注意")])),_:1})])]),s("ol",null,[s("li",null,[i[25]||(i[25]=l("git rebase -i 显示的提交日志顺序是由远到近, 最近的提交在最下面, 因为git会")),a(e,{color:"red"},{default:t(()=>i[24]||(i[24]=[l("从上到下依次重演每一个修改的提交")])),_:1}),i[26]||(i[26]=l(", 所有顺序是这样排序的. 因为是从上到下重演每一次提交, 所以, 你可以直接修改提交的顺序, 删除某一个提交(推荐用d命令)"))]),i[27]||(i[27]=s("li",null,"拆分提交, 使用e命令可以在重演到该提交时, 使用git add 和git commit 分多次提交修改的内容, 当提交完成后, 使用git rebase conitnue继续重演下一个提交",-1)),i[28]||(i[28]=s("li",null,"总结, rebase是从上到下依次重演提交内容的, 如果碰到中断的操作, 操作完成后, 需要使用git rebase --continue继续, 如果想放弃rebase, 使用git rebase --abort",-1)),i[29]||(i[29]=s("li",null,"filter-branch(全局修改)",-1))]),i[31]||(i[31]=r(`<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 用于全局修改提交邮箱和用户名, 整理自己的邮箱提交记录</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> filter-branch</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --commit-filter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;想要修改的邮箱地址&quot; ];</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  then</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">          GIT_AUTHOR_NAME=&quot;新用户名&quot;;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">          GIT_AUTHOR_EMAIL=&quot;新邮箱地址&quot;;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">          git commit-tree &quot;$@&quot;;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  else</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">          git commit-tree &quot;$@&quot;;</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  fi&#39;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> HEAD</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 全局删除某个文件</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> filter-branch</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --tree-filter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;rm -f xxx.txt&#39;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> HEAD</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1))])]),i[35]||(i[35]=s("h2",{id:"stash的使用",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#stash的使用"},[s("span",null,"stash的使用")])],-1)),i[36]||(i[36]=s("ul",null,[s("li",null,[l("目的 "),s("br"),l(" 一般用来在当前工作目录中有修改, 突然想切到其他分支上, 但是又不想提交这部分内容. 或者想将这部分内容带到其他分支上 "),s("ol",null,[s("li",null,[l("git stash "),s("br"),l(" 将当前修改和暂存的改动贮藏起来, 如果当前有未跟踪的新文件需要贮藏, 可以使用 git stash -u")]),s("li",null,[l("git stash list "),s("br"),l(" 查看当前贮藏的列表")]),s("li",{index:""},[l("git stash apply "),s("br"),l(" 应用贮藏的修改, 如果需要指定应用哪一个, 需要加上对应的index, 使用git stash apply stash@")]),s("li",null,[l("git stash drop stash@{index} "),s("br"),l(" 通过贮藏的名称移除贮藏")]),s("li",null,[l("git stash pop "),s("br"),l(" 常用操作, 应用最近的一个贮藏, 并且从栈中移除该贮藏, 相当于 git stash apply 和 git stash drop两个命令的结合")]),s("li",null,[l("git stash clear "),s("br"),l(" 清除贮藏区的所有内容, 注意, 此命令不可恢复")])])])],-1))])}const A=d(g,[["render",o]]),c=JSON.parse(`{"path":"/blog/tools/git/rebase.html","title":"变基","lang":"zh-CN","frontmatter":{"title":"变基","article":false,"index":true,"order":5,"description":"git变基 \\\\ git 合并其他分支的修改3种方式 、、 使用merge合并2个分支 假设开发分支feat和master, 在b2时分别有开发变更, 现在要将feat合并到master 合并前(在master分支) 合并后(git merge feat) 此时不满足快速合并, 会生成一个新的合并记录b5, 有2个父提交, master分支指向新的b5提...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"变基\\",\\"description\\":\\"git变基 \\\\\\\\ git 合并其他分支的修改3种方式 、、 使用merge合并2个分支 假设开发分支feat和master, 在b2时分别有开发变更, 现在要将feat合并到master 合并前(在master分支) 合并后(git merge feat) 此时不满足快速合并, 会生成一个新的合并记录b5, 有2个父提交, master分支指向新的b5提...\\"}"],["meta",{"property":"og:url","content":"https://codeloved.github.io/ccz-blog/ccz-blog/blog/tools/git/rebase.html"}],["meta",{"property":"og:site_name","content":"首页"}],["meta",{"property":"og:title","content":"变基"}],["meta",{"property":"og:description","content":"git变基 \\\\ git 合并其他分支的修改3种方式 、、 使用merge合并2个分支 假设开发分支feat和master, 在b2时分别有开发变更, 现在要将feat合并到master 合并前(在master分支) 合并后(git merge feat) 此时不满足快速合并, 会生成一个新的合并记录b5, 有2个父提交, master分支指向新的b5提..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-15T15:44:19.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-15T15:44:19.000Z"}]]},"git":{"createdTime":1747323859000,"updatedTime":1747323859000,"contributors":[{"name":"ccz","username":"ccz","email":"ccz@email","commits":1,"url":"https://github.com/ccz"}]},"readingTime":{"minutes":5.79,"words":1737},"filePathRelative":"blog/tools/git/rebase.md","excerpt":"<h2>git变基 \\\\</h2>\\n<p>git 合并其他分支的修改3种方式 、、</p>\\n<ul>\\n<li>\\n<p>使用merge合并2个分支 <br>\\n假设开发分支feat和master, 在b2时分别有开发变更, 现在要将feat合并到master</p>\\n<ol>\\n<li>合并前(在master分支)</li>\\n</ol>\\n<ol start=\\"2\\">\\n<li>合并后(git merge feat)</li>\\n</ol>\\n此时不满足快速合并, 会生成一个新的合并记录b5, 有2个父提交, master分支指向新的b5提交<ul>\\n<li>使用rebase合并2个分支\\n<ol>\\n<li>合并前(在feat分支)</li>\\n</ol>\\n<ol start=\\"2\\">\\n<li>rebase后(git rebase master)</li>\\n</ol>\\n<div class=\\"language-bash line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"bash\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">git</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> checkout</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> feat</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">git</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> rebase</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> master</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div> 先找到feat和master的共同祖先b2, 然后将当前分支(feat)基于共同祖先b2的历次提交暂存起来然后将当前分支feat指向目标分支master的最新提交b3, 再将暂存的提交以b3为基底重新提交一遍 <br>\\n总结就是, 相当于feat从基于共同最近祖先的提交(新增的提交)断开, 以master的最新提交为基底, 重演一遍断开的提交, 提交的id会改变,\\n也可能会存在冲突,需要解决冲突后继续提交,看起来好像是从master的b3处开始开发的, 然后再使用快速合并<div class=\\"language-bash line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"bash\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">git</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> checkout</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> master</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">git</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> merge</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> feat</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div> <ol>\\n<li>无论是直接合并的得到的b5, 还是先rebase再merge得到的b4', 指向的最终快照结果是完全一样的, 唯一的区别是提交的历史记录 <br>\\n如果先rebase再merge, 得到的提交历史是一条没有分叉的直线, 而不是直接合并会有一个合并节点, 使得并行工作的任务的提交记录,看起来和串行工作的提交记录一样的</li>\\n<li>一般使用情况, 先使用git fetch抓取最新的远程分支, 再使用git rebase origin/master变基, 然后推送到远端, 这样别人合并代码到主分支时, 不需要处理整合操作, 只需要快速合并即可</li>\\n<li>不论是rebase还是直接merge, 最终得到的快照结果, 一定是一样的, 唯一有区别的是提交历史</li>\\n<li>\\n  如果别人也基于相同远端分支开发, 并且已经检出了, 千万不要rebase, 会导致其他人的工作内容丢失和处理烦恼</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{A as comp,c as data};
